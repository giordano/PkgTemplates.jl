const TEST_UUID = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

"""
    generate(t::Template, pkg::AbstractString)
    generate(pkg::AbstractString, t::Template)

Generate a package named `pkg` from `t`.
"""
generate(t::Template, pkg::AbstractString) = generate(pkg, t)
function generate(pkg::AbstractString, t::Template)
    endswith(pkg, ".jl") && (pkg = pkg[1:end-3])
    pkg_dir = joinpath(t.dir, pkg)
    ispath(pkg_dir) && throw(ArgumentError("$pkg_dir already exists"))

    try
        # Create the directory with some boilerplate inside.
        Pkg.generate(pkg_dir)

        # Add a [compat] section for Julia.
        open(joinpath(pkg_dir, "Project.toml"), "a") do io
            println(io, "\n[compat]\njulia = $(repr_version(t.julia_version))")
        end

        # Replace the authors field with the template's authors.
        if !isempty(t.authors)
            path = joinpath(pkg_dir, "Project.toml")
            project = read(path, String)
            authors = string("[", join(map(repr âˆ˜ strip, split(t.authors, ",")), ", "), "]")
            write(path, replace(project, r"authors = .*" => "authors = $authors"))
        end

        if t.git
            # Initialize the repo.
            repo = LibGit2.init(pkg_dir)
            @info "Initialized Git repo at $pkg_dir"

            # Commit and set the remote.
            LibGit2.commit(repo, "Initial commit")
            rmt = if t.ssh
                "git@$(t.host):$(t.user)/$pkg.jl.git"
            else
                "https://$(t.host)/$(t.user)/$pkg.jl"
            end
            # We need to set the remote in a strange way, see #8.
            close(LibGit2.GitRemote(repo, "origin", rmt))
            @info "Set remote origin to $rmt"
        end

        # Generate the files.
        gen_tests(t, pkg_dir)
        gen_readme(t, pkg_dir)
        gen_license(t, pkg_dir)
        gen_gitignore(t, pkg_dir)
        gen_license(t, pkg_dir)
        foreach(p -> gen_plugin(p, t, pkg_dir), values(t.plugins))

        if t.git
            # Commit the files.
            LibGit2.add!(repo, ".")
            LibGit2.commit(repo, "Files generated by PkgTemplates")
            @info "Committed generated files"
        end

        if t.develop
            # Add the new package to the current environment.
            Pkg.develop(PackageSpec(; path=pkg_dir))
        end

        @info "New package is at $pkg_dir"
    catch e
        rm(pkg_dir; recursive=true, force=true)
        rethrow(e)
    end
end

# The make_* functions return (path, text) tuples, which are files that should be written.
# The gen_* functions write those files, along with any other required file manipulation.

function make_tests(t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = """
        using $pkg
        using Test

        @testset "$pkg.jl" begin
            # Write your own tests here.
        end
        """
    return [(joinpath(pkg_dir, "test", "runtests.jl"), text)]
end

function make_readme(t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = "# $pkg\n"

    # Generate the ordered badges first, then add any remaining ones to the right.
    done = DataType[]
    foreach(BADGE_ORDER) do T
        if haskey(t.plugins, T)
            text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
            push!(done, T)
        end
    end
    foreach(setdiff(keys(t.plugins), done)) do T
        text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
    end
    if haskey(t.plugins, Citation) && t.plugins[Citation].readme_section
        text *= "\n## Citing\n\nSee `CITATION.bib` for the relevant reference(s).\n"
    end


    return [(joinpath(pkg_dir, "README.md"), text)]
end

function make_gitignore(t::Template, pkg_dir::AbstractString)
    t.git || return ()

    entries = mapreduce(gitignore, append!, values(t.plugins); init=[".DS_Store", "/dev/"])
    # Only ignore manifests at the repo root.
    t.manifest || "Manifest.toml" in entries || push!(entries, "/Manifest.toml")

    unique!(sort!(entries))
    text = join(entries, "\n")

    return [(joinpath(pkg_dir, ".gitignore"), text)]
end

function make_license(t::Template, pkg_dir::AbstractString)
    isempty(t.license) && return ()
    text = "Copyright (c) $(year(today())) $(t.authors)\n"
    text *= read_license(t.license)
    return [(joinpath(pkg_dir, "LICENSE"), text)]
end

for f in (:require, :readme, :gitignore, :license)
    gen = Symbol(:gen_, f)
    make = Symbol(:make_, f)
    @eval $gen(t::Template, pkg_dir::AbstractString) = foreach(gen_file, $make(t, pkg_dir))
end

function gen_tests(t::Template, pkg_dir::AbstractString,)
    proj = Base.current_project()
    try
        # Add the Test dependency as a test-only dependency.
        # To avoid visual noise from adding/removing the dependency, insert it manually.
        Pkg.activate(pkg_dir)
        lines = split(read(joinpath(pkg_dir, "Project.toml"), String), "\n")
        dep = "Test = $(repr(TEST_UUID))"
        push!(lines, "[extras]", dep, "", "[targets]", "test = [\"Test\"]")
        gen_file(joinpath(pkg_dir, "Project.toml"), join(lines, "\n"))
        touch(joinpath(pkg_dir, "Manifest.toml"))  # File must exist to be modified by Pkg.
        Pkg.update()  # Clean up both Manifest.toml and Project.toml.
    finally
        proj === nothing ? Pkg.activate() : Pkg.activate(proj)
    end

    foreach(gen_file, make_tests(t, pkg_dir))
end
