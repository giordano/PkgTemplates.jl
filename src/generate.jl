const TEST_UUID = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

"""
    generate(t::Template, pkg::AbstractString)
    generate(pkg::AbstractString, t::Template)

Generate a package named `pkg` from `t`.
"""
generate(t::Template, pkg::AbstractString) = generate(pkg, t)
function generate(pkg::AbstractString, t::Template)
    endswith(pkg, ".jl") && (pkg = pkg[1:end-3])
    pkg_dir = joinpath(t.dir, pkg)
    ispath(pkg_dir) && throw(ArgumentError("$pkg_dir already exists"))

    try
        # Create the directory with some boilerplate inside.
        Pkg.generate(pkg_dir)

        # Add a [compat] section for Julia. By default, Julia 1.x is supported.
        open(joinpath(pkg_dir, "Project.toml"), "a") do io
            println(io, "\n[compat]\njulia = \"1\"")
        end

        # Replace the authors field with the template's authors.
        if !isempty(t.authors)
            path = joinpath(pkg_dir, "Project.toml")
            project = read(path, String)
            authors = string("[", join(map(repr âˆ˜ strip, split(t.authors, ",")), ", "), "]")
            write(path, replace(project, r"authors = .*" => "authors = $authors"))
        end

        if t.git
            # Initialize the repo.
            repo = LibGit2.init(pkg_dir)
            @info "Initialized Git repo at $pkg_dir"

            # Commit and set the remote.
            LibGit2.commit(repo, "Initial commit")
            rmt = if t.ssh
                "git@$(t.host):$(t.user)/$pkg.jl.git"
            else
                "https://$(t.host)/$(t.user)/$pkg.jl"
            end

            # Set the remote (in a weird way, see #8).
            close(LibGit2.GitRemote(repo, "origin", rmt))
            @info "Set remote origin to $rmt"
        end

        # Generate the files.
        foreach((gen_tests, gen_readme, gen_license, gen_gitignore, gen_license)) do f
            f(t, pkg_dir)
        end
        foreach(p -> gen_plugin(p, t, pkg_dir), values(t.plugins))

        if t.git
            # Commit the files.
            LibGit2.add!(repo, ".")
            LibGit2.commit(repo, "Files generated by PkgTemplates")
            @info "Committed generated files"
        end

        if t.develop
            # Add the new package to the current environment.
            Pkg.develop(PackageSpec(; path=pkg_dir))
        end

        @info "New package is at $pkg_dir"
    catch
        rm(pkg_dir; recursive=true, force=true)
        rethrow()
    end
end

# The make_* functions return (path, text) tuples, which are files that should be written.
# The gen_* functions write those files, along with any other required file manipulation.

function make_tests(t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = """
        using $pkg
        using Test

        @testset "$pkg.jl" begin
            # Write your own tests here.
        end
        """
    return [(joinpath(pkg_dir, "test", "runtests.jl"), text)]
end

function gen_readme(t::Template, pkg_dir::AbstractString)
    open(io -> gen_readme(io, t, pkg_dir), joinpath(pkg_dir, "README.md"), "w")
end
function gen_readme(io::IO, t::Template, pkg_dir::AbstractString)
    pkg = basename(pkg_dir)
    text = "# $pkg\n"

    # Generate the ordered badges first, then add any remaining ones to the right.
    done = DataType[]
    foreach(BADGE_ORDER) do T
        if hasplugin(t, T)
            text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
            push!(done, T)
        end
    end
    foreach(setdiff(keys(t.plugins), done)) do T
        bs = badges(t.plugins[T], t, pkg)
        text *= "\n" * join(badges(t.plugins[T], t.user, pkg), "\n")
    end
    if hasplugin(t, Citation) && t.plugins[Citation].readme_section
        text *= "\n## Citing\n\nSee [`CITATION.bib`](CITATION.bib) for the relevant reference(s)."
    end

    println(io, text)
end

function gen_gitignore(t::Template, pkg_dir::AbstractString)
    open(io -> gen_gitignore(io, t, pkg_dir), joinpath(pkg_dir, ".gitignore"), "w")
end
function gen_gitignore(io::IO, t::Template)
    t.git || return

    entries = mapreduce(gitignore, append!, values(t.plugins); init=[".DS_Store", "/dev/"])
    # Only ignore manifests at the repo root.
    t.manifest || "Manifest.toml" in entries || push!(entries, "/Manifest.toml")

    unique!(sort!(entries))
    println(io, join(entries, "\n"))
end

function gen_license(t::Template, pkg_dir::AbstractString)
    open(io -> gen_license(io, t), joinpath(pkg_dir, "LICENSE"), "w")
end
function gen_license(io::IO, t::Template)
    isempty(t.license) && return
    text = "Copyright (c) $(year(today())) $(t.authors)\n"
    text *= read_license(t.license)
    println(io, text)
end

function gen_tests(t::Template, pkg_dir::AbstractString)
    test = mkpath(joinpath(pkg_dir, "test"))
    open(io -> gen_tests(io, t, pkg_dir), joinpath(test, "runtests.jl"), "w")
end
function gen_tests(io::IO, t::Template, pkg_dir::AbstractString)
    proj = current_project()
    try
        # Add the Test dependency as a test-only dependency.
        # To avoid visual noise from adding/removing the dependency, insert it manually.
        Pkg.activate(pkg_dir)
        lines = split(read(joinpath(pkg_dir, "Project.toml"), String), "\n")
        dep = "Test = $(repr(TEST_UUID))"
        push!(lines, "[extras]", dep, "", "[targets]", "test = [\"Test\"]")
        gen_file(joinpath(pkg_dir, "Project.toml"), join(lines, "\n"))
        touch(joinpath(pkg_dir, "Manifest.toml"))  # File must exist to be modified by Pkg.
        Pkg.update()  # Clean up both Manifest.toml and Project.toml.
    finally
        proj === nothing ? Pkg.activate() : Pkg.activate(proj)
    end

    foreach(gen_file, make_tests(t, pkg_dir))
end
